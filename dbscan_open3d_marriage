import numpy as np
from sklearn.cluster import DBSCAN
from scipy.spatial.transform import Rotation
import time
import serial
import open3d as o3d
import json
import threading

# Threading and Synchronization
shared_active_points = np.empty((0, 3))  # Buffer for voxel indices
shared_active_colors = np.empty((0, 3))  # Buffer for corresponding colors
voxel_lock = threading.Lock()
running_event = threading.Event()
running_event.set()

start_time = time.time()

# Global Configuration
DO_VISUALIZATION = True
MAX_RUNTIME = 60
VOXEL_GRID_SIZE = 50.0
WORK_ENVIRONMENT_SIZE = np.array([1500, 1400, 1600])
VOXEL_MATRIX_SHAPE = (WORK_ENVIRONMENT_SIZE / VOXEL_GRID_SIZE).astype(int)

TIME_TOLERANCE = 1.0  # Seconds until a voxel is considered outdated

sensor_positions = np.array([
    [760.0, 700.0, 800],
    [737.410, 746.908, 800],
    [686.650, 758.494, 800],
    [645.946, 726.034, 800],
    [645.946, 673.966, 800],
    [686.650, 641.506, 800],
    [737.410, 653.092, 800],
])

sensor_rotation = np.array([
    [0.0, 0.0, 0.0],
    [0.0, 0.0, 51.43],
    [0.0, 0.0, 102.86],
    [0.0, 0.0, 154.29],
    [0.0, 0.0, 205.71],
    [0.0, 0.0, 257.14],
    [0.0, 0.0, 308.57],
])

ALL_SENSOR_ROTATION = np.array([[0.0, 0.0, 45.0]])
for i in range(len(sensor_rotation)):
    sensor_rotation[i] = sensor_rotation[i] + ALL_SENSOR_ROTATION

SENSOR_MATRIX_WIDTH = 8

# Clustering Parameters
DBSCAN_EPS = 3.0
DBSCAN_MIN_SAMPLES = 5
TOTAL_VELOCITY_TOLERANCE = 20.0

# voxel_matrix stores the timestamp (time.time()) of the last measurement
voxel_matrix = np.zeros(VOXEL_MATRIX_SHAPE, dtype=np.float64)


def get_voxel_coordinates(real_coordinate):
    """
    Converts real-world coordinates (Nx3) to voxel indices (Nx3)
    """
    voxel_coordinate = np.round(real_coordinate / VOXEL_GRID_SIZE)
    return voxel_coordinate.astype(int)


def get_real_coordinate(voxel_coordinate):
    """
    Converts voxel indices (Nx3) to real-world coordinates (Nx3)
    """
    return voxel_coordinate.astype(float) * VOXEL_GRID_SIZE


def get_sensor_rot(sensor_id):
    """
    Gets the rotation matrix for a specific sensor
    """
    angles = sensor_rotation[sensor_id]
    return Rotation.from_euler('xyz', angles, degrees=True)


def get_active_voxel_indices(time_now):
    """
    Gets all voxel indices that are younger than TIME_TOLERANCE.
    """
    indices = np.where((time_now - voxel_matrix) < TIME_TOLERANCE)
    return np.column_stack(indices).astype(int)


def is_valid_point(check_point):
    """
    Checks if a voxel index is within the matrix boundaries
    """
    return all(0 <= int(coord) < int(max_dim) for coord, max_dim in zip(check_point, VOXEL_MATRIX_SHAPE))


def read_json(json_input, time_now):
    """
    Parses JSON from the serial port and calls add_measurement
    """
    SENSORS_ON_RING = 7
    try:
        json_data = json.loads(json_input)
    except json.JSONDecodeError:
        print("Invalid JSON received. Resetting buffer.")
        if serial_connection:
            serial_connection.reset_input_buffer()
        return

    if not isinstance(json_data, dict):
        return

    for sensor_id in range(SENSORS_ON_RING):
        sensor_name = f"sensor{sensor_id}"
        if sensor_name not in json_data:
            continue

        distance_array = np.array([item[0] for item in json_data[sensor_name]])
        distance_matrix = distance_array.reshape((SENSOR_MATRIX_WIDTH, SENSOR_MATRIX_WIDTH))

        valid_mask = distance_matrix.flatten() > 0
        if not np.any(valid_mask):
            continue

        x, y, z = sensor_positions[sensor_id]
        rot = get_sensor_rot(sensor_id)

        i, j = np.meshgrid(np.arange(SENSOR_MATRIX_WIDTH), np.arange(SENSOR_MATRIX_WIDTH), indexing='ij')

        koo_x = np.tan(np.radians(60.0 / 7.0 * i - 30.0)) * distance_matrix
        koo_y = distance_matrix
        koo_z = np.tan(np.radians(30.0 - 60.0 / 7.0 * j)) * distance_matrix

        all_points = np.stack([koo_x, koo_y, koo_z], axis=-1)
        valid_points = all_points.reshape(-1, 3)[valid_mask]

        transformed_points = rot.apply(valid_points) + np.array([x, y, z])
        add_measurement(transformed_points, time_now)


def add_measurement(measured_real_coordinates, measurement_time):
    """
    Updates the voxel_matrix with new timestamps
    """
    measured_voxel_coordinates = get_voxel_coordinates(measured_real_coordinates)

    for coordinate in measured_voxel_coordinates:
        if is_valid_point(coordinate):
            voxel_matrix[tuple(coordinate)] = measurement_time


def get_dbscan_labels(voxel_indices):
    """
    Performs DBSCAN on voxel indices (fast).
    Returns an array of labels (-1 for noise).
    """
    if voxel_indices.size == 0:
        return np.array([])
    
    clustering = DBSCAN(eps=DBSCAN_EPS, min_samples=DBSCAN_MIN_SAMPLES).fit(voxel_indices)
    return clustering.labels_


all_detected_objects = []

class Detected_Object:
    """
    Stores the history of a detected object
    """
    def __init__(self, initial_voxels_indices, current_time):
        all_detected_objects.append(self)
        self.listed_voxels_list = [initial_voxels_indices] # List of (Nx3) arrays
        self.time_list = [current_time]
        # Assign a random color to this object
        self.color = np.random.rand(3)

    def add_new_voxels(self, new_voxels_indices, current_time):
        self.listed_voxels_list.append(new_voxels_indices)
        self.time_list.append(current_time)

    def check_overlap(self, other_voxels_indices, current_time):
        """
        Checks if a new cluster overlaps with the *current* voxels of this object
        """
        current_voxels = []
        for i, voxel_array in enumerate(self.listed_voxels_list):
            if current_time - self.time_list[i] < TIME_TOLERANCE:
                current_voxels.extend(voxel_array)
        
        set1 = set(map(tuple, current_voxels))
        set2 = set(map(tuple, other_voxels_indices))
        return len(set1.intersection(set2)) > 0

    def clean(self, current_time):
        """
        Removes old voxel entries and deletes the object if it becomes empty
        """
        filtered_data = [
            (voxels, t) for voxels, t in zip(self.listed_voxels_list, self.time_list)
            if (current_time - t) < TIME_TOLERANCE
        ]

        if filtered_data:
            self.listed_voxels_list, self.time_list = zip(*filtered_data)
            self.listed_voxels_list = list(self.listed_voxels_list)
            self.time_list = list(self.time_list)
        else:
            if self in all_detected_objects:
                all_detected_objects.remove(self)

    def estimate_movement_vector(self, current_time):
        """
        Estimates movement as the difference between centers in real coordinates
        """
        current_center = None
        previous_center = None
        
        valid_times = [t for t in self.time_list if (current_time - t) < TIME_TOLERANCE]
        if not valid_times:
            return np.array([0.0, 0.0, 0.0])
        
        latest_time = max(valid_times)
        latest_voxels = [v for v, t in zip(self.listed_voxels_list, self.time_list) if t == latest_time]
        if latest_voxels:
            current_center = np.mean(get_real_coordinate(np.vstack(latest_voxels)), axis=0)

        previous_times = [t for t in valid_times if t < latest_time]
        if previous_times:
            prev_time = max(previous_times)
            prev_voxels = [v for v, t in zip(self.listed_voxels_list, self.time_list) if t == prev_time]
            if prev_voxels:
                previous_center = np.mean(get_real_coordinate(np.vstack(prev_voxels)), axis=0)

        if current_center is not None and previous_center is not None:
            return current_center - previous_center
        
        return np.array([0.0, 0.0, 0.0])


# Serial Connection
try:
    serial_connection = serial.Serial(port='COM3', baudrate=460800, timeout=1)
except serial.SerialException as e:
    print(f"Failed to open COM3: {e}")
    print("Script will exit.")
    running_event.clear()
    serial_connection = None

all_cycle_times = []


def data_processing_thread():
    """
    Main thread for data processing (Read, Filter, Cluster)
    """
    global time_last_cycle_timestamp, shared_active_points, shared_active_colors

    time_last_cycle_timestamp = time.time()
    print("Starting data processing thread...")

    while running_event.is_set():
        time_now = time.time()

        if serial_connection is None or not serial_connection.is_open:
            print("Serial connection lost.")
            running_event.clear()
            break

        new_raw_line = serial_connection.readline().decode('utf-8').rstrip()
        if not new_raw_line:
            time.sleep(0.001)
            continue

        read_json(new_raw_line, time_now)

        active_voxel_indices = get_active_voxel_indices(time_now)

        if active_voxel_indices.size == 0:
            # Clear the buffer if nothing is active
            with voxel_lock:
                shared_active_points = np.empty((0, 3))
                shared_active_colors = np.empty((0, 3))
            time_last_cycle_timestamp = time_now
            continue

        # Clustering on voxel indices
        labels = get_dbscan_labels(active_voxel_indices)

        # Object Tracking
        unique_labels = set(labels) - {-1} # All cluster IDs, excluding noise

        for cluster_label in unique_labels:
            voxels_of_this_cluster_indices = active_voxel_indices[labels == cluster_label]
            
            voxels_allocated = False
            for detected_object in list(all_detected_objects):
                if detected_object.check_overlap(voxels_of_this_cluster_indices, time_now):
                    detected_object.add_new_voxels(voxels_of_this_cluster_indices, time_now)
                    voxels_allocated = True
                    break
            
            if not voxels_allocated:
                Detected_Object(voxels_of_this_cluster_indices, time_now)

        # Object Management (Movement & Cleanup)
        time_delta = time_now - time_last_cycle_timestamp
        if time_delta == 0: time_delta = 0.01

        for detected_object in list(all_detected_objects):
            mean_displacement = detected_object.estimate_movement_vector(time_now)
            
            if np.any(mean_displacement):
                velocity_vector = mean_displacement / time_delta
                total_velocity = np.linalg.norm(velocity_vector)
                if total_velocity > TOTAL_VELOCITY_TOLERANCE:
                    print(f"t = {(time_now - start_time):.2f}s: Movement: {total_velocity:.0f} mm/s")
            
            detected_object.clean(time_now) # Remove outdated objects/points

        # Visualization
        all_points_to_draw = []
        all_colors_to_draw = []

        for obj in list(all_detected_objects):
            if obj.listed_voxels_list: 
                latest_voxels = obj.listed_voxels_list[-1]
                all_points_to_draw.append(latest_voxels)
                
                color_array = np.tile(obj.color, (len(latest_voxels), 1))
                all_colors_to_draw.append(color_array)

        if all_points_to_draw:
            final_points = np.vstack(all_points_to_draw).astype(float)
            final_colors = np.vstack(all_colors_to_draw).astype(float)
        else:
            final_points = np.empty((0, 3))
            final_colors = np.empty((0, 3))

        with voxel_lock:
            shared_active_points = final_points
            shared_active_colors = final_colors

        # Cycle timing
        all_cycle_times.append(time.time() - time_now)
        time_last_cycle_timestamp = time_now

    if serial_connection is not None and serial_connection.is_open:
        serial_connection.close()
    print("Data processing thread finished.")


def setup_visualization(vis):
    """
    Sets up the scene, camera, and static geometries for Open3D
    """
    pcd_to_update = o3d.geometry.PointCloud()
    
    # Sensors as red spheres
    sensor_coords_scaled = sensor_positions / VOXEL_GRID_SIZE
    for pos in sensor_coords_scaled:
        sensor_sphere = o3d.geometry.TriangleMesh.create_sphere(radius=0.8)
        sensor_sphere.paint_uniform_color([1.0, 0.0, 0.0])
        sensor_sphere.translate(pos)
        vis.add_geometry(sensor_sphere)

    # Workspace bounding box
    room_bounds = o3d.geometry.AxisAlignedBoundingBox([0, 0, 0], VOXEL_MATRIX_SHAPE)
    room_lines = o3d.geometry.LineSet.create_from_axis_aligned_bounding_box(room_bounds)
    room_lines.paint_uniform_color([0.5, 0.5, 0.5])
    vis.add_geometry(room_lines)

    # Render options
    opt = vis.get_render_option()
    opt.background_color = np.array([0.15, 0.15, 0.18])
    opt.point_size = 3.0
    opt.line_width = 1.5
    opt.light_on = True

    # Camera
    ctr = vis.get_view_control()
    ctr.set_front([0.5, -0.5, 0.8])
    ctr.set_lookat(VOXEL_MATRIX_SHAPE / 2)
    ctr.set_up([0, 0, 1])
    ctr.set_zoom(0.8)

    vis.add_geometry(pcd_to_update)
    return pcd_to_update


if __name__ == "__main__":
    if DO_VISUALIZATION and running_event.is_set():
        print("Starting render thread (main thread)...")

        vis = o3d.visualization.Visualizer()
        vis.create_window("Open3D Live Voxel", width=1200, height=900)
        
        pcd = setup_visualization(vis)

        processing_thread = threading.Thread(target=data_processing_thread)
        processing_thread.start()

        print("Starting Open3D visualizer...")

        while running_event.is_set():
            with voxel_lock:
                points_data = shared_active_points
                colors_data = shared_active_colors

            # Check for data presence
            if points_data.size > 0:
                pcd.points = o3d.utility.Vector3dVector(points_data)
                
                # Check for color consistency
                if len(points_data) == len(colors_data):
                    pcd.colors = o3d.utility.Vector3dVector(colors_data)
                else:
                    # Fallback
                    pcd.paint_uniform_color([0.1, 0.1, 0.9])
            else:
                pcd.points = o3d.utility.Vector3dVector(np.empty((0, 3)))
                pcd.colors = o3d.utility.Vector3dVector(np.empty((0, 3)))

            vis.update_geometry(pcd)


            if not vis.poll_events():
                 running_event.clear()
                 break
            vis.update_renderer()
            
            if not processing_thread.is_alive():
                print("Data thread has stopped.")
                running_event.clear()
            
            time.sleep(0.016)

        vis.destroy_window()
        processing_thread.join()

    elif running_event.is_set():
        data_processing_thread()

    end_time = time.time()
    print(f"Total runtime: {end_time - start_time:.2f} sec.")
    if all_cycle_times:
        avg_cycle_ms = np.mean(all_cycle_times) * 1000
        print(f"Average cycle time: {avg_cycle_ms:.2f} ms ({len(all_cycle_times)} cycles)")
    else:
        print("No cycles processed.")
