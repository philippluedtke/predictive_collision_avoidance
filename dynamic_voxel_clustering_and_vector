import numpy as np
from sklearn.cluster import DBSCAN
from scipy.spatial.transform import Rotation
import time
import serial
import open3d as o3d
import json
import threading

# Threading Setup
shared_active_points = np.empty((0, 3))
shared_active_colors = np.empty((0, 3))
shared_vector_lines = {'points': np.empty((0, 3)), 'lines': np.empty((0, 2))}
voxel_lock = threading.Lock() # Lock to protect shared buffers
running_event = threading.Event()
running_event.set()

start_time = time.time()

# Global Configuration
DO_VISUALIZATION = True
MAX_RUNTIME = 60
VOXEL_GRID_SIZE = 50.0 
WORK_ENVIRONMENT_SIZE = np.array([1500, 1400, 1600])
VOXEL_MATRIX_SHAPE = (WORK_ENVIRONMENT_SIZE / VOXEL_GRID_SIZE).astype(int)

TIME_TOLERANCE = 1.0

# Sensor Ring Setup
sensor_positions = np.array([
    [760.0, 700.0, 800],
    [737.410, 653.092, 800],
    [686.650, 641.506, 800],
    [645.946, 673.966, 800],
    [645.946, 726.034, 800],
    [686.650, 758.494, 800],
    [737.410, 746.908, 800],
])

sensor_rotation = np.array([
    [0.0, 0.0, 0.0],
    [0.0, 0.0, 308.57],
    [0.0, 0.0, 257.14],
    [0.0, 0.0, 205.71],
    [0.0, 0.0, 154.29],
    [0.0, 0.0, 102.86],
    [0.0, 0.0, 51.43],
])

ALL_SENSOR_ROTATION = np.array([[0.0, 0.0, 45.0]])
for i in range(len(sensor_rotation)):
    sensor_rotation[i] = sensor_rotation[i] + ALL_SENSOR_ROTATION

SENSOR_MATRIX_WIDTH = 8

# Clustering Config
DBSCAN_EPS = 1.5
DBSCAN_MIN_SAMPLES = 8
TOTAL_VELOCITY_TOLERANCE = 20.0 
VECTOR_SCALE_FACTOR = 5.0 

# Background Removal Config
STATIC_HIT_THRESHOLD = 100 

# Voxel Grids
voxel_matrix = np.zeros(VOXEL_MATRIX_SHAPE, dtype=np.float64)
static_voxel_matrix = np.zeros(VOXEL_MATRIX_SHAPE, dtype=np.uint32)


def get_voxel_coordinates(real_coordinate):
    """
    Converting real-world coordinates (mm) to voxel grid indices
    """
    voxel_coordinate = np.round(real_coordinate / VOXEL_GRID_SIZE)
    return voxel_coordinate.astype(int)

def get_real_coordinate(voxel_coordinate):
    """
    Converting voxel grid indices back to real-world (mm)
    """
    return voxel_coordinate.astype(float) * VOXEL_GRID_SIZE

def get_sensor_rot(sensor_id):
    """
    Get the pre-calculated scipy Rotation object for a sensor
    """
    angles = sensor_rotation[sensor_id]
    return Rotation.from_euler('xyz', angles, degrees=True)

def get_active_voxel_indices(time_now):
    """
    Finding all voxel indices that are active within TIME_TOLERANCE
    """
    indices = np.where((time_now - voxel_matrix) < TIME_TOLERANCE)
    return np.column_stack(indices).astype(int)

def is_valid_point(check_point):
    """
    Check if a voxel index is within the matrix boundaries
    """
    return all(0 <= int(coord) < int(max_dim) for coord, max_dim in zip(check_point, VOXEL_MATRIX_SHAPE))

def read_json(json_input, time_now):
    """
    Parsing the JSON string from the serial port and updates the voxel grid
    """
    SENSORS_ON_RING = 7
    try:
        json_data = json.loads(json_input)
    except json.JSONDecodeError:
        print("Invalid JSON received. Resetting buffer")
        if serial_connection:
            serial_connection.reset_input_buffer()
        return

    if not isinstance(json_data, dict):
        return

    for sensor_id in range(SENSORS_ON_RING):
        sensor_name = f"sensor{sensor_id}"
        if sensor_name not in json_data:
            continue

        distance_array = np.array([item[0] for item in json_data[sensor_name]])
        distance_matrix = distance_array.reshape((SENSOR_MATRIX_WIDTH, SENSOR_MATRIX_WIDTH))

        valid_mask = distance_matrix.flatten() > 0
        if not np.any(valid_mask):
            continue

        x, y, z = sensor_positions[sensor_id]
        rot = get_sensor_rot(sensor_id)

        i, j = np.meshgrid(np.arange(SENSOR_MATRIX_WIDTH), np.arange(SENSOR_MATRIX_WIDTH), indexing='ij')

        koo_x = np.tan(np.radians(60.0 / 7.0 * i - 30.0)) * distance_matrix
        koo_y = distance_matrix
        koo_z = np.tan(np.radians(30.0 - 60.0 / 7.0 * j)) * distance_matrix

        all_points = np.stack([koo_x, koo_y, koo_z], axis=-1)
        valid_points = all_points.reshape(-1, 3)[valid_mask]

        transformed_points = rot.apply(valid_points) + np.array([x, y, z])
        add_measurement(transformed_points, time_now)

def add_measurement(measured_real_coordinates, measurement_time):
    """
    Updates the main voxel_matrix (timestamp) and static_voxel_matrix (hit count).
    """
    measured_voxel_coordinates = get_voxel_coordinates(measured_real_coordinates)

    for coordinate in measured_voxel_coordinates:
        if is_valid_point(coordinate):
            coord_tuple = tuple(coordinate)
            voxel_matrix[coord_tuple] = measurement_time
            if static_voxel_matrix[coord_tuple] < STATIC_HIT_THRESHOLD:
                static_voxel_matrix[coord_tuple] += 1

def get_dbscan_labels(voxel_indices):
    """
    Performs DBSCAN clustering on the given voxel indices.
    """
    if voxel_indices.size == 0:
        return np.array([])
    clustering = DBSCAN(eps=DBSCAN_EPS, min_samples=DBSCAN_MIN_SAMPLES).fit(voxel_indices)
    return clustering.labels_


# Object Tracking Logic
class Detected_Object:
    """
    Tracks one object's point history.
    """
    def __init__(self, initial_voxels_indices, current_time):
        """
        Initializes a new tracked object.
        """
        self.listed_voxels_list = [initial_voxels_indices] 
        self.time_list = [current_time]
        self.color = np.random.rand(3)

    def add_new_voxels(self, new_voxels_indices, current_time):
        """
        Append the latest set of voxels to this object's history.
        """
        self.listed_voxels_list.append(new_voxels_indices)
        self.time_list.append(current_time)

    def get_active_voxels_set(self, current_time):
        """
        Get all voxels for this object that are still 'live'.
        """
        active_voxels = []
        for v, t in zip(self.listed_voxels_list, self.time_list):
            if (current_time - t) < TIME_TOLERANCE:
                active_voxels.extend(v)
        return set(map(tuple, active_voxels))

    def clean(self, current_time):
        """
        Clean voxel sets older than TIME_TOLERANCE.
        """
        filtered_data = [
            (voxels, t) for voxels, t in zip(self.listed_voxels_list, self.time_list)
            if (current_time - t) < TIME_TOLERANCE
        ]
        if filtered_data:
            self.listed_voxels_list, self.time_list = zip(*filtered_data)
            self.listed_voxels_list = list(self.listed_voxels_list)
            self.time_list = list(self.time_list)
        else:
            self.listed_voxels_list = []
            self.time_list = []

    def is_alive(self):
        """
        Checks if the object has any active voxel data.
        """
        return bool(self.listed_voxels_list)

    def get_latest_voxels(self):
        """
        Gets the most recent set of voxels for this object.
        """
        return self.listed_voxels_list[-1] if self.is_alive() else np.empty((0,3))

    def estimate_movement_vector(self, current_time):
        """
        Estimate velocity from centroid diff.
        Returns: (displacement_vec, current_center_mm)
        """
        current_center = None
        previous_center = None
        
        valid_times = [t for t in self.time_list if (current_time - t) < TIME_TOLERANCE]
        if not valid_times:
            return np.array([0.0, 0.0, 0.0]), None 
        
        latest_time = max(valid_times)
        latest_voxels = [v for v, t in zip(self.listed_voxels_list, self.time_list) if t == latest_time]
        if latest_voxels:
            current_center = np.mean(get_real_coordinate(np.vstack(latest_voxels)), axis=0)
        else:
            return np.array([0.0, 0.0, 0.0]), None

        previous_times = [t for t in valid_times if t < latest_time]
        if previous_times:
            prev_time = max(previous_times)
            prev_voxels = [v for v, t in zip(self.listed_voxels_list, self.time_list) if t == prev_time]
            if prev_voxels:
                previous_center = np.mean(get_real_coordinate(np.vstack(prev_voxels)), axis=0)

        if current_center is not None and previous_center is not None:
            return (current_center - previous_center), current_center
        
        return np.array([0.0, 0.0, 0.0]), current_center

class ObjectTracker:
    """
    Manages all Detected_Object instances, handles matching, creation, deletion, and visualization data prep
    """
    def __init__(self):
        """
        Initializes the tracker with an empty list of objects.
        """
        self.objects = []
        self.current_vectors = []

    def update(self, dynamic_voxels, labels, time_now, time_delta):
        """
        Update loop: matches new clusters to existing objects or creates new ones.
        """
        unique_labels = set(labels) - {-1}
        
        # Matching new clusters to existing objects by overlap
        unmatched_labels = set()
        object_voxel_sets = [(obj, obj.get_active_voxels_set(time_now)) for obj in self.objects]

        for label in unique_labels:
            cluster_voxels = dynamic_voxels[labels == label]
            cluster_set = set(map(tuple, cluster_voxels))
            
            matched_obj = None
            for obj, obj_set in object_voxel_sets:
                if cluster_set.intersection(obj_set):
                    matched_obj = obj
                    break 
            
            if matched_obj:
                matched_obj.add_new_voxels(cluster_voxels, time_now)
            else:
                unmatched_labels.add(label) # Will become a new object
        
        # Creating new objects for unmatched clusters
        for label in unmatched_labels:
            new_cluster_voxels = dynamic_voxels[labels == label]
            self.objects.append(Detected_Object(new_cluster_voxels, time_now))
            
        # Clean up, manage, and calculate vectors
        self.manage_objects(time_now, time_delta)

    def manage_objects(self, time_now, time_delta):
        """
        Cleans stale objects and calculates velocity vectors for live ones
        """
        vectors = []
        for i in range(len(self.objects) - 1, -1, -1):
            obj = self.objects[i]
            obj.clean(time_now)
            
            if not obj.is_alive():
                self.objects.pop(i)
                continue
                
            # Calculate velocity
            displacement, center = obj.estimate_movement_vector(time_now)
            if center is not None and np.any(displacement):
                velocity = np.linalg.norm(displacement / time_delta)
                if velocity > TOTAL_VELOCITY_TOLERANCE:
                     print(f"t = {(time_now - start_time):.2f}s: Movement: {velocity:.0f} mm/s")
                
                start_voxel = get_voxel_coordinates(center)
                end_voxel = get_voxel_coordinates(center + displacement * VECTOR_SCALE_FACTOR)
                vectors.append((start_voxel, end_voxel))
        
        self.current_vectors = vectors # Store for visualization

    def get_visualization_data(self):
        """
        Builds and returns all geometry for the Open3D visualizer
        Returns:(points, colors), (vector_points, vector_lines)
        """
        points_list = []
        colors_list = []
        
        for obj in self.objects:
            latest_voxels = obj.get_latest_voxels()
            points_list.append(latest_voxels)
            colors_list.append(np.tile(obj.color, (len(latest_voxels), 1)))

        vector_points = []
        vector_lines = []
        for i, (start, end) in enumerate(self.current_vectors):
            vector_points.extend([start, end])
            vector_lines.append([i*2, i*2 + 1])
            
        # Final numpy arrays
        final_points = np.vstack(points_list) if points_list else np.empty((0,3))
        final_colors = np.vstack(colors_list) if colors_list else np.empty((0,3))
        final_vec_points = np.array(vector_points, dtype=float)
        final_vec_lines = np.array(vector_lines, dtype=int)
        
        return (final_points, final_colors), (final_vec_points, final_vec_lines)

# Serial Connection
try:
    serial_connection = serial.Serial(port='COM3', baudrate=460800, timeout=1)
except serial.SerialException as e:
    print(f"Failed to open COM: {e}")
    running_event.clear()
    serial_connection = None

all_cycle_times = []


def data_processing_thread():
    """
    Main data loop: Read -> Filter -> Cluster -> Track. Running in dedicted thread
    """
    global shared_active_points, shared_active_colors, shared_vector_lines
    
    tracker = ObjectTracker()
    time_last_cycle_timestamp = time.time()

    print("Starting data processing thread...")

    while running_event.is_set():
        time_now = time.time()

        if serial_connection is None or not serial_connection.is_open:
            print("Serial connection lost.")
            running_event.clear()
            break

        new_raw_line = serial_connection.readline().decode('utf-8').rstrip()
        if not new_raw_line:
            time.sleep(0.001)
            continue

        read_json(new_raw_line, time_now)

        all_active_voxel_indices = get_active_voxel_indices(time_now)

        if all_active_voxel_indices.size == 0:
            with voxel_lock:
                shared_active_points = np.empty((0, 3))
                shared_active_colors = np.empty((0, 3))
                shared_vector_lines = {'points': np.empty((0, 3)), 'lines': np.empty((0, 2))}
            time_last_cycle_timestamp = time_now
            continue

        # Background Subtraction
        dynamic_voxel_indices_list = []
        for idx in all_active_voxel_indices:
            if static_voxel_matrix[tuple(idx)] < STATIC_HIT_THRESHOLD:
                dynamic_voxel_indices_list.append(idx)
        
        dynamic_voxel_indices = np.array(dynamic_voxel_indices_list)

        # Clustering
        labels = get_dbscan_labels(dynamic_voxel_indices)

        # Object Tracking
        time_delta = time_now - time_last_cycle_timestamp
        if time_delta == 0: time_delta = 0.01 
        
        tracker.update(dynamic_voxel_indices, labels, time_now, time_delta)

        # Visualization Buffer
        (points, colors), (vec_points, vec_lines) = tracker.get_visualization_data()

        with voxel_lock:
            shared_active_points = points
            shared_active_colors = colors
            shared_vector_lines['points'] = vec_points
            shared_vector_lines['lines'] = vec_lines

        all_cycle_times.append(time.time() - time_now)
        time_last_cycle_timestamp = time_now

    if serial_connection is not None and serial_connection.is_open:
        serial_connection.close()
    print("Data processing thread finished")


def setup_visualization(vis):
    """
    Set up the Open3D visualizer scene, camera, and static geometry. Returning (pcd, line_set) geometries that can be updated
    """
    pcd_to_update = o3d.geometry.PointCloud()
    
    sensor_coords_scaled = sensor_positions / VOXEL_GRID_SIZE
    for pos in sensor_coords_scaled:
        sensor_sphere = o3d.geometry.TriangleMesh.create_sphere(radius=0.8)
        sensor_sphere.paint_uniform_color([1.0, 0.0, 0.0])
        sensor_sphere.translate(pos)
        vis.add_geometry(sensor_sphere)

    room_bounds = o3d.geometry.AxisAlignedBoundingBox([0, 0, 0], VOXEL_MATRIX_SHAPE)
    room_lines = o3d.geometry.LineSet.create_from_axis_aligned_bounding_box(room_bounds)
    room_lines.paint_uniform_color([0.5, 0.5, 0.5])
    vis.add_geometry(room_lines)

    coord_frame = o3d.geometry.TriangleMesh.create_coordinate_frame(
        size=10.0, origin=[0, 0, 0]
    )
    vis.add_geometry(coord_frame)

    opt = vis.get_render_option()
    opt.background_color = np.array([0.15, 0.15, 0.18])
    opt.point_size = 3.0
    opt.line_width = 3.0 
    opt.light_on = True

    ctr = vis.get_view_control()
    ctr.set_front([0, 0, 1])
    ctr.set_lookat(VOXEL_MATRIX_SHAPE / 2) 
    ctr.set_up([0, 1, 0])
    ctr.set_zoom(0.8)

    vis.add_geometry(pcd_to_update)
    line_set_to_update = o3d.geometry.LineSet()
    vis.add_geometry(line_set_to_update)
    
    return pcd_to_update, line_set_to_update


if __name__ == "__main__":
    if DO_VISUALIZATION and running_event.is_set():
        print("Starting render thread (main thread)...")
        vis = o3d.visualization.Visualizer()
        vis.create_window("Open3D Live Voxel", width=1200, height=900)
        
        pcd, line_set = setup_visualization(vis)

        processing_thread = threading.Thread(target=data_processing_thread)
        processing_thread.start()

        print("Starting Open3D visualizer...")

        while running_event.is_set():
            with voxel_lock:
                points_data = shared_active_points
                colors_data = shared_active_colors
                vector_points_data = shared_vector_lines['points']
                vector_lines_data = shared_vector_lines['lines']

            # Updating points/ object
            if points_data.size > 0:
                pcd.points = o3d.utility.Vector3dVector(points_data)
                pcd.colors = o3d.utility.Vector3dVector(colors_data)
            else:
                pcd.points = o3d.utility.Vector3dVector(np.empty((0, 3)))
                pcd.colors = o3d.utility.Vector3dVector(np.empty((0, 3)))
            vis.update_geometry(pcd)

            # Updating vector
            if vector_points_data.size > 0:
                line_set.points = o3d.utility.Vector3dVector(vector_points_data)
                line_set.lines = o3d.utility.Vector2iVector(vector_lines_data)
                line_set.paint_uniform_color([1.0, 1.0, 0.0])
            else:
                line_set.points = o3d.utility.Vector3dVector(np.empty((0, 3)))
                line_set.lines = o3d.utility.Vector2iVector(np.empty((0, 2)))
            vis.update_geometry(line_set)

            if not vis.poll_events():
                running_event.clear() 
                break
            vis.update_renderer()
            
            if not processing_thread.is_alive():
                print("Data thread has stopped")
                running_event.clear()
            
            time.sleep(0.016)

        vis.destroy_window()
        processing_thread.join() 

    elif running_event.is_set():
        data_processing_thread()

    end_time = time.time()
    print(f"Total runtime: {end_time - start_time:.2f} sec")
    if all_cycle_times:
        avg_cycle_ms = np.mean(all_cycle_times) * 1000
        print(f"Average cycle time: {avg_cycle_ms:.2f} ms ({len(all_cycle_times)} cycles)")
    else:
        print("No cycles processed")
